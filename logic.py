{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e22a9a0b-836f-4283-9d11-f738aeee6f66",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import os\n",
    "\n",
    "# --- Constants ---\n",
    "# Pantry staples are given less weight in the matching algorithm.\n",
    "# If a user is missing \"salt\", it shouldn't disqualify a recipe as much as missing \"chicken\".\n",
    "PANTRY_STAPLES = {\n",
    "    \"salt\", \"pepper\", \"water\", \"oil\", \"olive oil\", \"sugar\", \"flour\", \n",
    "    \"butter\", \"garlic\", \"onion\", \"soy sauce\", \"vinegar\"\n",
    "}\n",
    "\n",
    "def load_recipes():\n",
    "    \"\"\"Loads the database securely with error handling.\"\"\"\n",
    "    try:\n",
    "        with open('recipes.json', 'r') as f:\n",
    "            return json.load(f)\n",
    "    except FileNotFoundError:\n",
    "        return []\n",
    "    except json.JSONDecodeError:\n",
    "        return []\n",
    "\n",
    "def calculate_match_score(user_ingredients, recipe_ingredients):\n",
    "    \"\"\"\n",
    "    Advanced Matching Logic:\n",
    "    - Calculates a weighted score.\n",
    "    - Core ingredients (not in pantry list) count for 2 points.\n",
    "    - Pantry staples count for 1 point.\n",
    "    \"\"\"\n",
    "    user_set = set(i.lower().strip() for i in user_ingredients)\n",
    "    recipe_set = set(i.lower().strip() for i in recipe_ingredients)\n",
    "    \n",
    "    if not recipe_set:\n",
    "        return 0, []\n",
    "\n",
    "    total_possible_score = 0\n",
    "    current_score = 0\n",
    "    \n",
    "    missing_items = []\n",
    "\n",
    "    for ingredient in recipe_set:\n",
    "        # Determine weight\n",
    "        weight = 1 if ingredient in PANTRY_STAPLES else 2\n",
    "        total_possible_score += weight\n",
    "        \n",
    "        # Check if user has it\n",
    "        # We check if the recipe ingredient string exists in user inputs (partial match support)\n",
    "        # e.g. user \"cheddar cheese\" matches recipe \"cheese\"\n",
    "        match_found = False\n",
    "        for user_item in user_set:\n",
    "            if user_item in ingredient or ingredient in user_item:\n",
    "                match_found = True\n",
    "                break\n",
    "        \n",
    "        if match_found:\n",
    "            current_score += weight\n",
    "        else:\n",
    "            missing_items.append(ingredient)\n",
    "\n",
    "    # Avoid division by zero\n",
    "    if total_possible_score == 0:\n",
    "        return 0, []\n",
    "        \n",
    "    final_score = current_score / total_possible_score\n",
    "    return final_score, missing_items\n",
    "\n",
    "def find_matching_recipes(user_ingredients, recipes):\n",
    "    \"\"\"\n",
    "    Filters and sorts recipes based on the weighted match score.\n",
    "    Returns recipes with at least a 30% match.\n",
    "    \"\"\"\n",
    "    results = []\n",
    "\n",
    "    for recipe in recipes:\n",
    "        score, missing = calculate_match_score(user_ingredients, recipe['ingredients'])\n",
    "        \n",
    "        # Threshold: Show recipe if > 30% match\n",
    "        if score >= 0.30:\n",
    "            # Add calculated fields to the recipe object for the UI to use\n",
    "            recipe_copy = recipe.copy()\n",
    "            recipe_copy['match_score'] = score\n",
    "            recipe_copy['missing_ingredients'] = missing\n",
    "            results.append(recipe_copy)\n",
    "    \n",
    "    # Sort by highest score first\n",
    "    return sorted(results, key=lambda x: x['match_score'], reverse=True)\n",
    "\n",
    "def filter_recipes(recipes, dietary_filter=None, difficulty_filter=None):\n",
    "    \"\"\"Applies side-bar filters.\"\"\"\n",
    "    filtered = recipes\n",
    "    if dietary_filter and dietary_filter != \"None\":\n",
    "        filtered = [r for r in filtered if dietary_filter in r.get('dietary', [])]\n",
    "    if difficulty_filter and difficulty_filter != \"Any\":\n",
    "        filtered = [r for r in filtered if r.get('difficulty') == difficulty_filter]\n",
    "    return filtered\n",
    "\n",
    "def get_substitutions(ingredient):\n",
    "    \"\"\"Provides substitution suggestions[cite: 33].\"\"\"\n",
    "    subs = {\n",
    "        \"milk\": \"almond milk, soy milk, or water\",\n",
    "        \"butter\": \"olive oil, coconut oil, or margarine\",\n",
    "        \"egg\": \"flax seed meal (1 tbsp + 3 tbsp water), applesauce, or yogurt\",\n",
    "        \"soy sauce\": \"tamari (gluten-free) or coconut aminos\",\n",
    "        \"sugar\": \"honey, maple syrup, or stevia\",\n",
    "        \"flour\": \"gluten-free blend, almond flour, or oat flour\",\n",
    "        \"ground beef\": \"lentils, turkey, or plant-based crumble\",\n",
    "        \"cream\": \"coconut milk or greek yogurt\"\n",
    "    }\n",
    "    # Simple partial match for substitution key\n",
    "    for key, value in subs.items():\n",
    "        if key in ingredient.lower():\n",
    "            return value\n",
    "    return None"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
